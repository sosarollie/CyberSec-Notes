/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => SupSubPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var import_view = require("@codemirror/view");
var DEFAULT_SETTINGS = {
  enablePopup: true,
  hideTags: true
};
var tagDecoration = import_view.Decoration.mark({
  attributes: {
    style: "display: none;"
  }
});
var supDecoration = import_view.Decoration.mark({
  attributes: {
    class: "cm-sup"
  }
});
var subDecoration = import_view.Decoration.mark({
  attributes: {
    class: "cm-sub"
  }
});
var supSubDecorationPlugin = import_view.ViewPlugin.define((view) => {
  let decorations = import_view.Decoration.none;
  const doc = view.state.doc.toString();
  const regex = /<(sup|sub)>(.*?)<\/\1>/g;
  let match;
  while ((match = regex.exec(doc)) !== null) {
    const tag = match[1];
    const content = match[2];
    const from = match.index;
    const to = from + match[0].length;
    const openTagStart = from;
    const openTagEnd = from + `<${tag}>`.length;
    const closeTagStart = to - `</${tag}>`.length;
    const closeTagEnd = to;
    decorations = decorations.update({
      add: [tagDecoration.range(openTagStart, openTagEnd)]
    });
    decorations = decorations.update({
      add: [tagDecoration.range(closeTagStart, closeTagEnd)]
    });
    if (tag === "sup") {
      decorations = decorations.update({
        add: [supDecoration.range(openTagEnd, closeTagStart)]
      });
    } else if (tag === "sub") {
      decorations = decorations.update({
        add: [subDecoration.range(openTagEnd, closeTagStart)]
      });
    }
  }
  return {
    decorations
  };
}, {
  decorations: (v) => v.decorations
});
var SupSubSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "SupSub Settings" });
    new import_obsidian.Setting(containerEl).setName("Enable Popup Buttons").setDesc("Toggle the visibility of the SupSub popup buttons when text is selected.").addToggle((toggle) => toggle.setValue(this.plugin.settings.enablePopup).onChange(async (value) => {
      this.plugin.settings.enablePopup = value;
      await this.plugin.saveSettings();
      new import_obsidian.Notice(`Popup Buttons ${value ? "Enabled" : "Disabled"}`);
      if (!value) {
        this.plugin.hideSupSubButtons();
        this.plugin.selectionStart = null;
        this.plugin.selectionEnd = null;
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Hide Sup/Sub Tags").setDesc("Instantly hide the <sup> and <sub> tags in Editor Mode after wrapping.").addToggle((toggle) => toggle.setValue(this.plugin.settings.hideTags).onChange(async (value) => {
      this.plugin.settings.hideTags = value;
      await this.plugin.saveSettings();
      new import_obsidian.Notice(`Hide Tags ${value ? "Enabled" : "Disabled"}`);
      this.plugin.refreshDecorations();
    }));
  }
};
var SupSubPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.styleEl = null;
    this.isWrapping = false;
    this.selectionStart = null;
    this.selectionEnd = null;
    this.supSubDecorations = null;
  }
  async onload() {
    console.log("SupSub Plugin loaded");
    await this.loadSettings();
    this.addSettingTab(new SupSubSettingTab(this.app, this));
    this.addCommand({
      id: "wrap-sup",
      name: "Wrap with <sup> tags",
      editorCallback: (editor, view) => this.wrapSelection("sup", editor),
      hotkeys: [
        {
          modifiers: ["Mod", "Alt"],
          key: "="
        }
      ]
    });
    this.addCommand({
      id: "wrap-sub",
      name: "Wrap with <sub> tags",
      editorCallback: (editor, view) => this.wrapSelection("sub", editor),
      hotkeys: [
        {
          modifiers: ["Mod", "Alt"],
          key: "-"
        }
      ]
    });
    const style = `
            .supsub-popup {
                position: absolute;
                background: var(--background-primary);
                border: 1px solid var(--border);
                padding: 5px;
                border-radius: 8px;
                box-shadow: 0 2px 5px rgba(0,0,0,0.2);
                z-index: 10000;
                display: flex;
                gap: 5px;
                transition: opacity 0.1s ease;
                opacity: 0;
                pointer-events: none;
            }
            .supsub-popup.visible {
                opacity: 1;
                pointer-events: auto;
            }
            .supsub-popup button {
                background: var(--background-modifier-hover);
                border: none;
                padding: 5px 10px;
                border-radius: 4px;
                cursor: pointer;
                font-size: 12px;
                transition: background 0.2s ease;
            }
            .supsub-popup button:hover {
                background: var(--background-modifier-hover-active);
            }
            .cm-sup {
                vertical-align: super;
                font-size: smaller;
            }
            .cm-sub {
                vertical-align: sub;
                font-size: smaller;
            }
        `;
    this.styleEl = document.createElement("style");
    this.styleEl.innerText = style;
    document.head.appendChild(this.styleEl);
    this.register(() => {
      if (this.styleEl) {
        this.styleEl.remove();
      }
    });
    this.registerEvent(this.app.workspace.on("editor-selection-change", (editor) => {
      if (this.isWrapping)
        return;
      const selection = editor.getSelection();
      if (selection && this.settings.enablePopup) {
        this.showSupSubButtons(editor);
      } else {
        this.hideSupSubButtons();
      }
    }));
    this.registerDomEvent(document, "click", (evt) => {
      const target = evt.target;
      if (!target.closest(".supsub-popup")) {
        this.hideSupSubButtons();
      }
    });
    if (this.settings.hideTags) {
      this.supSubDecorations = this.registerEditorExtension(supSubDecorationPlugin);
    }
  }
  onunload() {
    console.log("SupSub Plugin unloaded");
    this.hideSupSubButtons();
    if (this.styleEl) {
      this.styleEl.remove();
    }
    if (this.supSubDecorations) {
      this.supSubDecorations = null;
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  refreshDecorations() {
    if (this.settings.hideTags) {
      if (!this.supSubDecorations) {
        this.supSubDecorations = this.registerEditorExtension(supSubDecorationPlugin);
      }
    } else {
      if (this.supSubDecorations) {
        this.supSubDecorations = null;
      }
    }
  }
  showSupSubButtons(editor) {
    if (!this.settings.enablePopup)
      return;
    this.hideSupSubButtons();
    const selection = editor.getSelection();
    if (!selection)
      return;
    const cursorStart = editor.getCursor("from");
    const cursorEnd = editor.getCursor("to");
    this.selectionStart = { ...cursorStart };
    this.selectionEnd = { ...cursorEnd };
    const currentTag = this.getCurrentTag(selection);
    const buttonContainer = document.createElement("div");
    buttonContainer.className = "supsub-popup";
    if (currentTag === "sup" || currentTag === "sub") {
      const normalButton = document.createElement("button");
      normalButton.innerText = "Normal (n)";
      normalButton.setAttribute("aria-label", "Remove superscript/subscript");
      normalButton.addEventListener("mousedown", (e) => {
        e.preventDefault();
        e.stopPropagation();
        this.wrapSelection(currentTag, editor);
      });
      buttonContainer.appendChild(normalButton);
    } else {
      const supButton = document.createElement("button");
      supButton.innerText = "Sup (\u207F)";
      supButton.setAttribute("aria-label", "Wrap selected text with superscript");
      supButton.addEventListener("mousedown", (e) => {
        e.preventDefault();
        e.stopPropagation();
        this.wrapSelection("sup", editor);
      });
      const subButton = document.createElement("button");
      subButton.innerText = "Sub (\u2089)";
      subButton.setAttribute("aria-label", "Wrap selected text with subscript");
      subButton.addEventListener("mousedown", (e) => {
        e.preventDefault();
        e.stopPropagation();
        this.wrapSelection("sub", editor);
      });
      buttonContainer.appendChild(supButton);
      buttonContainer.appendChild(subButton);
    }
    buttonContainer.style.position = "absolute";
    document.body.appendChild(buttonContainer);
    this.positionPopup(buttonContainer, editor);
    requestAnimationFrame(() => {
      buttonContainer.classList.add("visible");
    });
  }
  hideSupSubButtons() {
    const buttonContainers = document.querySelectorAll(".supsub-popup");
    buttonContainers.forEach((buttonContainer) => {
      buttonContainer.classList.remove("visible");
      setTimeout(() => {
        buttonContainer.remove();
      }, 100);
    });
  }
  positionPopup(popup, editor) {
    const selection = window.getSelection();
    if (selection && selection.rangeCount > 0) {
      const range = selection.getRangeAt(0);
      const rect = range.getBoundingClientRect();
      const top = rect.bottom + window.scrollY + 5;
      const left = rect.left + rect.width / 2 - popup.offsetWidth / 2;
      const maxLeft = window.innerWidth - popup.offsetWidth - 10;
      const calculatedLeft = Math.max(10, Math.min(left, maxLeft));
      popup.style.top = `${top}px`;
      popup.style.left = `${calculatedLeft}px`;
      console.log(`Popup positioned at top: ${top}px, left: ${calculatedLeft}px`);
    }
  }
  wrapSelection(tag, editor) {
    this.isWrapping = true;
    try {
      if (this.selectionStart && this.selectionEnd) {
        const docLines = editor.lineCount();
        const isValidStart = this.selectionStart.line >= 0 && this.selectionStart.line < docLines && this.selectionStart.ch >= 0 && this.selectionStart.ch <= editor.getLine(this.selectionStart.line).length;
        const isValidEnd = this.selectionEnd.line >= 0 && this.selectionEnd.line < docLines && this.selectionEnd.ch >= 0 && this.selectionEnd.ch <= editor.getLine(this.selectionEnd.line).length;
        if (isValidStart && isValidEnd) {
          editor.setSelection(this.selectionStart, this.selectionEnd);
        } else {
          console.warn("Invalid selection points. Clearing selectionStart and selectionEnd.");
          this.selectionStart = null;
          this.selectionEnd = null;
        }
      }
      editor.focus();
      setTimeout(() => {
        const selection = editor.getSelection();
        console.log(`Wrapping selection: "${selection}" with tag: <${tag}>`);
        if (selection) {
          const regex = new RegExp(`<${tag}>(.*?)</${tag}>`, "s");
          const matches = regex.exec(selection);
          if (matches) {
            const debracketedSelection = matches[1];
            editor.replaceSelection(debracketedSelection);
            new import_obsidian.Notice(`${tag} tags removed`);
          } else {
            const wrappedSelection = `<${tag}>${selection}</${tag}>`;
            editor.replaceSelection(wrappedSelection);
            new import_obsidian.Notice(`${tag} tags added`);
          }
          this.hideSupSubButtons();
          if (this.settings.hideTags) {
            const cursor = editor.getCursor();
            const lineContent = editor.getLine(cursor.line);
            const optimizedLine = this.optimizeTags(lineContent, tag);
            editor.setLine(cursor.line, optimizedLine);
          }
          const newCursor = editor.getCursor("to");
          editor.setSelection(newCursor, newCursor);
          editor.scrollIntoView({
            from: editor.getCursor("from"),
            to: editor.getCursor("to"),
            center: true
          });
        }
      }, 50);
    } catch (error) {
      console.error("Error in wrapSelection:", error);
      new import_obsidian.Notice("An error occurred while wrapping selection.");
    } finally {
      this.isWrapping = false;
    }
  }
  optimizeTags(line, tag) {
    const openTag = `<${tag}>`;
    const closeTag = `</${tag}>`;
    let optimizedLine = line.replace(new RegExp(`(${closeTag})(${openTag})`, "g"), "");
    optimizedLine = optimizedLine.replace(new RegExp(`\\${openTag}\\s*\\${closeTag}`, "g"), "");
    return optimizedLine;
  }
  getCurrentTag(selection) {
    const supRegex = /^<sup>([\s\S]+)<\/sup>$/i;
    const subRegex = /^<sub>([\s\S]+)<\/sub>$/i;
    if (supRegex.test(selection)) {
      return "sup";
    } else if (subRegex.test(selection)) {
      return "sub";
    } else {
      return null;
    }
  }
};


/* nosourcemap */